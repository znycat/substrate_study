"use strict";
var _MetadataVersioned_converted, _MetadataVersioned_assertVersion, _MetadataVersioned_getVersion, _MetadataVersioned_metadata;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetadataVersioned = void 0;
const tslib_1 = require("tslib");
const types_codec_1 = require("@polkadot/types-codec");
const index_js_1 = require("./util/index.js");
const toV10_js_1 = require("./v9/toV10.js");
const toV11_js_1 = require("./v10/toV11.js");
const toV12_js_1 = require("./v11/toV12.js");
const toV13_js_1 = require("./v12/toV13.js");
const toV14_js_1 = require("./v13/toV14.js");
const toLatest_js_1 = require("./v14/toLatest.js");
const MagicNumber_js_1 = require("./MagicNumber.js");
const KNOWN_VERSIONS = [14, 13, 12, 11, 10, 9];
const LATEST_VERSION = KNOWN_VERSIONS[0];
/**
 * @name MetadataVersioned
 * @description
 * The versioned runtime metadata as a decoded structure
 */
class MetadataVersioned extends types_codec_1.Struct {
    constructor(registry, value) {
        // const timeStart = performance.now()
        super(registry, {
            magicNumber: MagicNumber_js_1.MagicNumber,
            metadata: 'MetadataAll'
        }, value);
        _MetadataVersioned_converted.set(this, new Map());
        _MetadataVersioned_assertVersion.set(this, (version) => {
            if (this.version > version) {
                throw new Error(`Cannot convert metadata from version ${this.version} to ${version}`);
            }
            return this.version === version;
        });
        _MetadataVersioned_getVersion.set(this, (version, fromPrev) => {
            const asCurr = `asV${version}`;
            const asPrev = version === 'latest'
                ? `asV${LATEST_VERSION}`
                : `asV${version - 1}`;
            if (version !== 'latest' && tslib_1.__classPrivateFieldGet(this, _MetadataVersioned_assertVersion, "f").call(this, version)) {
                return tslib_1.__classPrivateFieldGet(this, _MetadataVersioned_metadata, "f").call(this)[asCurr];
            }
            if (!tslib_1.__classPrivateFieldGet(this, _MetadataVersioned_converted, "f").has(version)) {
                tslib_1.__classPrivateFieldGet(this, _MetadataVersioned_converted, "f").set(version, fromPrev(this.registry, this[asPrev], this.version));
            }
            return tslib_1.__classPrivateFieldGet(this, _MetadataVersioned_converted, "f").get(version);
        });
        /**
         * @description the metadata wrapped
         */
        _MetadataVersioned_metadata.set(this, () => {
            return this.getT('metadata');
        });
        // console.log('MetadataVersioned', `${(performance.now() - timeStart).toFixed(2)}ms`)
    }
    /**
     * @description Returns the wrapped metadata as a limited calls-only (latest) version
     */
    get asCallsOnly() {
        return new MetadataVersioned(this.registry, {
            magicNumber: this.magicNumber,
            metadata: this.registry.createTypeUnsafe('MetadataAll', [(0, index_js_1.toCallsOnly)(this.registry, this.asLatest), LATEST_VERSION])
        });
    }
    /**
     * @description Returns the wrapped metadata as a V9 object
     */
    get asV9() {
        tslib_1.__classPrivateFieldGet(this, _MetadataVersioned_assertVersion, "f").call(this, 9);
        return tslib_1.__classPrivateFieldGet(this, _MetadataVersioned_metadata, "f").call(this).asV9;
    }
    /**
     * @description Returns the wrapped values as a V10 object
     */
    get asV10() {
        return tslib_1.__classPrivateFieldGet(this, _MetadataVersioned_getVersion, "f").call(this, 10, toV10_js_1.toV10);
    }
    /**
     * @description Returns the wrapped values as a V11 object
     */
    get asV11() {
        return tslib_1.__classPrivateFieldGet(this, _MetadataVersioned_getVersion, "f").call(this, 11, toV11_js_1.toV11);
    }
    /**
     * @description Returns the wrapped values as a V12 object
     */
    get asV12() {
        return tslib_1.__classPrivateFieldGet(this, _MetadataVersioned_getVersion, "f").call(this, 12, toV12_js_1.toV12);
    }
    /**
     * @description Returns the wrapped values as a V13 object
     */
    get asV13() {
        return tslib_1.__classPrivateFieldGet(this, _MetadataVersioned_getVersion, "f").call(this, 13, toV13_js_1.toV13);
    }
    /**
     * @description Returns the wrapped values as a V14 object
     */
    get asV14() {
        return tslib_1.__classPrivateFieldGet(this, _MetadataVersioned_getVersion, "f").call(this, 14, toV14_js_1.toV14);
    }
    /**
     * @description Returns the wrapped values as a latest version object
     */
    get asLatest() {
        return tslib_1.__classPrivateFieldGet(this, _MetadataVersioned_getVersion, "f").call(this, 'latest', toLatest_js_1.toLatest);
    }
    /**
     * @description The magicNumber for the Metadata (known constant)
     */
    get magicNumber() {
        return this.getT('magicNumber');
    }
    /**
     * @description the metadata version this structure represents
     */
    get version() {
        return tslib_1.__classPrivateFieldGet(this, _MetadataVersioned_metadata, "f").call(this).index;
    }
    getUniqTypes(throwError) {
        return (0, index_js_1.getUniqTypes)(this.registry, this.asLatest, throwError);
    }
    /**
     * @description Converts the Object to JSON, typically used for RPC transfers
     */
    toJSON() {
        // HACK(y): ensure that we apply the aliases if we have not done so already, this is
        // needed to ensure we have the correct overrides (which is only applied in toLatest)
        // eslint-disable-next-line no-unused-expressions
        this.asLatest;
        return super.toJSON();
    }
}
exports.MetadataVersioned = MetadataVersioned;
_MetadataVersioned_converted = new WeakMap(), _MetadataVersioned_assertVersion = new WeakMap(), _MetadataVersioned_getVersion = new WeakMap(), _MetadataVersioned_metadata = new WeakMap();
