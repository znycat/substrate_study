"use strict";
var _GenericEventData_meta, _GenericEventData_method, _GenericEventData_names, _GenericEventData_section, _GenericEventData_typeDef;
Object.defineProperty(exports, "__esModule", { value: true });
exports.GenericEvent = exports.GenericEventData = void 0;
const tslib_1 = require("tslib");
const types_codec_1 = require("@polkadot/types-codec");
const util_1 = require("@polkadot/util");
/** @internal */
function decodeEvent(registry, value) {
    if (!value || !value.length) {
        return { DataType: types_codec_1.Null };
    }
    const index = value.subarray(0, 2);
    return {
        DataType: registry.findMetaEvent(index),
        value: {
            data: value.subarray(2),
            index
        }
    };
}
/**
 * @name GenericEventData
 * @description
 * Wrapper for the actual data that forms part of an [[Event]]
 */
class GenericEventData extends types_codec_1.Tuple {
    constructor(registry, value, meta, section = '<unknown>', method = '<unknown>') {
        const fields = meta?.fields || [];
        super(registry, fields.map(({ type }) => registry.createLookupType(type)), value);
        _GenericEventData_meta.set(this, void 0);
        _GenericEventData_method.set(this, void 0);
        _GenericEventData_names.set(this, null);
        _GenericEventData_section.set(this, void 0);
        _GenericEventData_typeDef.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _GenericEventData_meta, meta, "f");
        tslib_1.__classPrivateFieldSet(this, _GenericEventData_method, method, "f");
        tslib_1.__classPrivateFieldSet(this, _GenericEventData_section, section, "f");
        tslib_1.__classPrivateFieldSet(this, _GenericEventData_typeDef, fields.map(({ type }) => registry.lookup.getTypeDef(type)), "f");
        const names = fields
            .map(({ name }) => registry.lookup.sanitizeField(name)[0])
            .filter((n) => !!n);
        if (names.length === fields.length) {
            tslib_1.__classPrivateFieldSet(this, _GenericEventData_names, names, "f");
            (0, util_1.objectProperties)(this, names, (_, i) => this[i]);
        }
    }
    /**
     * @description The wrapped [[EventMetadata]]
     */
    get meta() {
        return tslib_1.__classPrivateFieldGet(this, _GenericEventData_meta, "f");
    }
    /**
     * @description The method as a string
     */
    get method() {
        return tslib_1.__classPrivateFieldGet(this, _GenericEventData_method, "f");
    }
    /**
     * @description The field names (as available)
     */
    get names() {
        return tslib_1.__classPrivateFieldGet(this, _GenericEventData_names, "f");
    }
    /**
     * @description The section as a string
     */
    get section() {
        return tslib_1.__classPrivateFieldGet(this, _GenericEventData_section, "f");
    }
    /**
     * @description The [[TypeDef]] for this event
     */
    get typeDef() {
        return tslib_1.__classPrivateFieldGet(this, _GenericEventData_typeDef, "f");
    }
    /**
     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
     */
    toHuman(isExtended) {
        if (tslib_1.__classPrivateFieldGet(this, _GenericEventData_names, "f") !== null) {
            const json = {};
            for (let i = 0; i < tslib_1.__classPrivateFieldGet(this, _GenericEventData_names, "f").length; i++) {
                json[tslib_1.__classPrivateFieldGet(this, _GenericEventData_names, "f")[i]] = this[i].toHuman(isExtended);
            }
            return json;
        }
        return super.toHuman(isExtended);
    }
}
exports.GenericEventData = GenericEventData;
_GenericEventData_meta = new WeakMap(), _GenericEventData_method = new WeakMap(), _GenericEventData_names = new WeakMap(), _GenericEventData_section = new WeakMap(), _GenericEventData_typeDef = new WeakMap();
/**
 * @name GenericEvent
 * @description
 * A representation of a system event. These are generated via the [[Metadata]] interfaces and
 * specific to a specific Substrate runtime
 */
class GenericEvent extends types_codec_1.Struct {
    // Currently we _only_ decode from Uint8Array, since we expect it to
    // be used via EventRecord
    constructor(registry, _value) {
        const { DataType, value } = decodeEvent(registry, _value);
        super(registry, {
            index: 'EventId',
            // eslint-disable-next-line sort-keys
            data: DataType
        }, value);
    }
    /**
     * @description The wrapped [[EventData]]
     */
    get data() {
        return this.getT('data');
    }
    /**
     * @description The [[EventId]], identifying the raw event
     */
    get index() {
        return this.getT('index');
    }
    /**
     * @description The [[EventMetadata]] with the documentation
     */
    get meta() {
        return this.data.meta;
    }
    /**
     * @description The method string identifying the event
     */
    get method() {
        return this.data.method;
    }
    /**
     * @description The section string identifying the event
     */
    get section() {
        return this.data.section;
    }
    /**
     * @description The [[TypeDef]] for the event
     */
    get typeDef() {
        return this.data.typeDef;
    }
    /**
     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information
     */
    toHuman(isExpanded) {
        return (0, util_1.objectSpread)({
            method: this.method,
            section: this.section
        }, isExpanded
            ? { docs: this.meta.docs.map((d) => d.toString()) }
            : null, super.toHuman(isExpanded));
    }
}
exports.GenericEvent = GenericEvent;
