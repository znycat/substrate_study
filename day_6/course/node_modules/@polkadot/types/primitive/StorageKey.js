var _StorageKey_args, _StorageKey_meta, _StorageKey_outputType, _StorageKey_method, _StorageKey_section;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { Bytes } from '@polkadot/types-codec';
import { isFunction, isString, isU8a } from '@polkadot/util';
import { getSiName } from '../metadata/util/index.js';
const HASHER_MAP = {
    // opaque
    Blake2_128: [16, false],
    Blake2_128Concat: [16, true],
    Blake2_256: [32, false],
    Identity: [0, true],
    Twox128: [16, false],
    Twox256: [32, false],
    Twox64Concat: [8, true]
};
export function unwrapStorageSi(type) {
    return type.isPlain
        ? type.asPlain
        : type.asMap.value;
}
/** @internal */
export function unwrapStorageType(registry, type, isOptional) {
    const outputType = getSiName(registry.lookup, unwrapStorageSi(type));
    return isOptional
        ? `Option<${outputType}>`
        : outputType;
}
/** @internal */
function decodeStorageKey(value) {
    if (isU8a(value) || !value || isString(value)) {
        // let Bytes handle these inputs
        return { key: value };
    }
    else if (value instanceof StorageKey) {
        return {
            key: value,
            method: value.method,
            section: value.section
        };
    }
    else if (isFunction(value)) {
        return {
            key: value(),
            method: value.method,
            section: value.section
        };
    }
    else if (Array.isArray(value)) {
        const [fn, args = []] = value;
        if (!isFunction(fn)) {
            throw new Error('Expected function input for key construction');
        }
        if (fn.meta && fn.meta.type.isMap) {
            const map = fn.meta.type.asMap;
            if (!Array.isArray(args) || args.length !== map.hashers.length) {
                throw new Error(`Expected an array of ${map.hashers.length} values as params to a Map query`);
            }
        }
        return {
            // This is unknown[] above (also where assigned), the linter thinks it is any[] here
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            key: fn(...args),
            method: fn.method,
            section: fn.section
        };
    }
    throw new Error(`Unable to convert input ${value} to StorageKey`);
}
/** @internal */
function decodeHashers(registry, value, hashers) {
    // the storage entry is xxhashAsU8a(prefix, 128) + xxhashAsU8a(method, 128), 256 bits total
    let offset = 32;
    const result = new Array(hashers.length);
    for (let i = 0; i < hashers.length; i++) {
        const [hasher, type] = hashers[i];
        const [hashLen, canDecode] = HASHER_MAP[hasher.type];
        const decoded = canDecode
            ? registry.createTypeUnsafe(getSiName(registry.lookup, type), [value.subarray(offset + hashLen)])
            : registry.createTypeUnsafe('Raw', [value.subarray(offset, offset + hashLen)]);
        offset += hashLen + (canDecode ? decoded.encodedLength : 0);
        result[i] = decoded;
    }
    return result;
}
/** @internal */
function decodeArgsFromMeta(registry, value, meta) {
    if (!meta || !meta.type.isMap) {
        return [];
    }
    const { hashers, key } = meta.type.asMap;
    const keys = hashers.length === 1
        ? [key]
        : registry.lookup.getSiType(key).def.asTuple;
    return decodeHashers(registry, value, hashers.map((h, i) => [h, keys[i]]));
}
/** @internal */
function getMeta(value) {
    if (value instanceof StorageKey) {
        return value.meta;
    }
    else if (isFunction(value)) {
        return value.meta;
    }
    else if (Array.isArray(value)) {
        const [fn] = value;
        return fn.meta;
    }
    return undefined;
}
/** @internal */
function getType(registry, value) {
    if (value instanceof StorageKey) {
        return value.outputType;
    }
    else if (isFunction(value)) {
        return unwrapStorageType(registry, value.meta.type);
    }
    else if (Array.isArray(value)) {
        const [fn] = value;
        if (fn.meta) {
            return unwrapStorageType(registry, fn.meta.type);
        }
    }
    // If we have no type set, default to Raw
    return 'Raw';
}
/**
 * @name StorageKey
 * @description
 * A representation of a storage key (typically hashed) in the system. It can be
 * constructed by passing in a raw key or a StorageEntry with (optional) arguments.
 */
export class StorageKey extends Bytes {
    constructor(registry, value, override = {}) {
        const { key, method, section } = decodeStorageKey(value);
        super(registry, key);
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore This is assigned via this.decodeArgsFromMeta()
        _StorageKey_args.set(this, void 0);
        _StorageKey_meta.set(this, void 0);
        _StorageKey_outputType.set(this, void 0);
        _StorageKey_method.set(this, void 0);
        _StorageKey_section.set(this, void 0);
        __classPrivateFieldSet(this, _StorageKey_outputType, getType(registry, value), "f");
        // decode the args (as applicable based on the key and the hashers, after all init)
        this.setMeta(getMeta(value), override.section || section, override.method || method);
    }
    /**
     * @description Return the decoded arguments (applicable to map with decodable values)
     */
    get args() {
        return __classPrivateFieldGet(this, _StorageKey_args, "f");
    }
    /**
     * @description The metadata or `undefined` when not available
     */
    get meta() {
        return __classPrivateFieldGet(this, _StorageKey_meta, "f");
    }
    /**
     * @description The key method or `undefined` when not specified
     */
    get method() {
        return __classPrivateFieldGet(this, _StorageKey_method, "f");
    }
    /**
     * @description The output type
     */
    get outputType() {
        return __classPrivateFieldGet(this, _StorageKey_outputType, "f");
    }
    /**
     * @description The key section or `undefined` when not specified
     */
    get section() {
        return __classPrivateFieldGet(this, _StorageKey_section, "f");
    }
    is(key) {
        return key.section === this.section && key.method === this.method;
    }
    /**
     * @description Sets the meta for this key
     */
    setMeta(meta, section, method) {
        __classPrivateFieldSet(this, _StorageKey_meta, meta, "f");
        __classPrivateFieldSet(this, _StorageKey_method, method || __classPrivateFieldGet(this, _StorageKey_method, "f"), "f");
        __classPrivateFieldSet(this, _StorageKey_section, section || __classPrivateFieldGet(this, _StorageKey_section, "f"), "f");
        if (meta) {
            __classPrivateFieldSet(this, _StorageKey_outputType, unwrapStorageType(this.registry, meta.type), "f");
        }
        try {
            __classPrivateFieldSet(this, _StorageKey_args, decodeArgsFromMeta(this.registry, this.toU8a(true), meta), "f");
        }
        catch (error) {
            // ignore...
        }
        return this;
    }
    /**
     * @description Returns the Human representation for this type
     */
    toHuman() {
        return __classPrivateFieldGet(this, _StorageKey_args, "f").length
            ? __classPrivateFieldGet(this, _StorageKey_args, "f").map((a) => a.toHuman())
            : super.toHuman();
    }
    /**
     * @description Returns the raw type for this
     */
    toRawType() {
        return 'StorageKey';
    }
}
_StorageKey_args = new WeakMap(), _StorageKey_meta = new WeakMap(), _StorageKey_outputType = new WeakMap(), _StorageKey_method = new WeakMap(), _StorageKey_section = new WeakMap();
