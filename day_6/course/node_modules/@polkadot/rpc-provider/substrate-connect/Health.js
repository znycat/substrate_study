var _InnerChecker_healthCallback, _InnerChecker_currentHealthCheckId, _InnerChecker_currentHealthTimeout, _InnerChecker_currentSubunsubRequestId, _InnerChecker_currentSubscriptionId, _InnerChecker_requestToSmoldot, _InnerChecker_isSyncing, _InnerChecker_nextRequestId, _HealthCheckError_cause;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { stringify } from '@polkadot/util';
/*
 * Creates a new health checker.
 *
 * The role of the health checker is to report to the user the health of a smoldot chain.
 *
 * In order to use it, start by creating a health checker, and call `setSendJsonRpc` to set the
 * way to send a JSON-RPC request to a chain. The health checker is disabled by default. Use
 * `start()` in order to start the health checks. The `start()` function must be passed a callback called
 * when an update to the health of the node is available.
 *
 * In order to send a JSON-RPC request to the chain, you **must** use the `sendJsonRpc` function
 * of the health checker. The health checker rewrites the `id` of the requests it receives.
 *
 * When the chain send a JSON-RPC response, it must be passed to `responsePassThrough()`. This
 * function intercepts the responses destined to the requests that have been emitted by the health
 * checker and returns `null`. If the response doesn't concern the health checker, the response is
 * simply returned by the function.
 *
 * # How it works
 *
 * The health checker periodically calls the `system_health` JSON-RPC call in order to determine
 * the health of the chain.
 *
 * In addition to this, as long as the health check reports that `isSyncing` is `true`, the
 * health checker also maintains a subscription to new best blocks using `chain_subscribeNewHeads`.
 * Whenever a new block is notified, a health check is performed immediately in order to determine
 * whether `isSyncing` has changed to `false`.
 *
 * Thanks to this subscription, the latency of the report of the switch from `isSyncing: true` to
 * `isSyncing: false` is very low.
 *
 */
export function healthChecker() {
    // `null` if health checker is not started.
    let checker = null;
    let sendJsonRpc = null;
    return {
        responsePassThrough: (jsonRpcResponse) => {
            if (checker === null) {
                return jsonRpcResponse;
            }
            return checker.responsePassThrough(jsonRpcResponse);
        },
        sendJsonRpc: (request) => {
            if (!sendJsonRpc) {
                throw new Error('setSendJsonRpc must be called before sending requests');
            }
            if (checker === null) {
                sendJsonRpc(request);
            }
            else {
                checker.sendJsonRpc(request);
            }
        },
        setSendJsonRpc: (cb) => {
            sendJsonRpc = cb;
        },
        start: (healthCallback) => {
            if (checker !== null) {
                throw new Error("Can't start the health checker multiple times in parallel");
            }
            else if (!sendJsonRpc) {
                throw new Error('setSendJsonRpc must be called before starting the health checks');
            }
            checker = new InnerChecker(healthCallback, sendJsonRpc);
            checker.update(true);
        },
        stop: () => {
            if (checker === null) {
                return;
            } // Already stopped.
            checker.destroy();
            checker = null;
        }
    };
}
class InnerChecker {
    constructor(healthCallback, requestToSmoldot) {
        _InnerChecker_healthCallback.set(this, void 0);
        _InnerChecker_currentHealthCheckId.set(this, null);
        _InnerChecker_currentHealthTimeout.set(this, null);
        _InnerChecker_currentSubunsubRequestId.set(this, null);
        _InnerChecker_currentSubscriptionId.set(this, null);
        _InnerChecker_requestToSmoldot.set(this, void 0);
        _InnerChecker_isSyncing.set(this, false);
        _InnerChecker_nextRequestId.set(this, 0);
        this.sendJsonRpc = (request) => {
            // Replace the `id` in the request to prefix the request ID with `extern:`.
            let parsedRequest;
            try {
                parsedRequest = JSON.parse(request);
            }
            catch (err) {
                return;
            }
            if (parsedRequest.id) {
                const newId = 'extern:' + stringify(parsedRequest.id);
                parsedRequest.id = newId;
            }
            __classPrivateFieldGet(this, _InnerChecker_requestToSmoldot, "f").call(this, parsedRequest);
        };
        this.responsePassThrough = (jsonRpcResponse) => {
            let parsedResponse;
            try {
                parsedResponse = JSON.parse(jsonRpcResponse);
            }
            catch (err) {
                return jsonRpcResponse;
            }
            // Check whether response is a response to `system_health`.
            if (parsedResponse.id && __classPrivateFieldGet(this, _InnerChecker_currentHealthCheckId, "f") === parsedResponse.id) {
                __classPrivateFieldSet(this, _InnerChecker_currentHealthCheckId, null, "f");
                // Check whether query was successful. It is possible for queries to fail for
                // various reasons, such as the client being overloaded.
                if (!parsedResponse.result) {
                    this.update(false);
                    return null;
                }
                __classPrivateFieldGet(this, _InnerChecker_healthCallback, "f").call(this, parsedResponse.result);
                __classPrivateFieldSet(this, _InnerChecker_isSyncing, parsedResponse.result.isSyncing, "f");
                this.update(false);
                return null;
            }
            // Check whether response is a response to the subscription or unsubscription.
            if (parsedResponse.id &&
                __classPrivateFieldGet(this, _InnerChecker_currentSubunsubRequestId, "f") === parsedResponse.id) {
                __classPrivateFieldSet(this, _InnerChecker_currentSubunsubRequestId, null, "f");
                // Check whether query was successful. It is possible for queries to fail for
                // various reasons, such as the client being overloaded.
                if (!parsedResponse.result) {
                    this.update(false);
                    return null;
                }
                if (__classPrivateFieldGet(this, _InnerChecker_currentSubscriptionId, "f")) {
                    __classPrivateFieldSet(this, _InnerChecker_currentSubscriptionId, null, "f");
                }
                else {
                    __classPrivateFieldSet(this, _InnerChecker_currentSubscriptionId, parsedResponse.result, "f");
                }
                this.update(false);
                return null;
            }
            // Check whether response is a notification to a subscription.
            if (parsedResponse.params &&
                __classPrivateFieldGet(this, _InnerChecker_currentSubscriptionId, "f") &&
                parsedResponse.params.subscription === __classPrivateFieldGet(this, _InnerChecker_currentSubscriptionId, "f")) {
                // Note that after a successful subscription, a notification containing
                // the current best block is always returned. Considering that a
                // subscription is performed in response to a health check, calling
                // `startHealthCheck()` here will lead to a second health check.
                // It might seem redundant to perform two health checks in a quick
                // succession, but doing so doesn't lead to any problem, and it is
                // actually possible for the health to have changed in between as the
                // current best block might have been updated during the subscription
                // request.
                this.update(true);
                return null;
            }
            // Response doesn't concern us.
            if (parsedResponse.id) {
                const id = parsedResponse.id;
                // Need to remove the `extern:` prefix.
                if (!id.startsWith('extern:')) {
                    throw new Error('State inconsistency in health checker');
                }
                const newId = JSON.parse(id.slice('extern:'.length));
                parsedResponse.id = newId;
            }
            return stringify(parsedResponse);
        };
        this.update = (startNow) => {
            // If `startNow`, clear `#currentHealthTimeout` so that it is set below.
            if (startNow && __classPrivateFieldGet(this, _InnerChecker_currentHealthTimeout, "f")) {
                clearTimeout(__classPrivateFieldGet(this, _InnerChecker_currentHealthTimeout, "f"));
                __classPrivateFieldSet(this, _InnerChecker_currentHealthTimeout, null, "f");
            }
            if (!__classPrivateFieldGet(this, _InnerChecker_currentHealthTimeout, "f")) {
                const startHealthRequest = () => {
                    __classPrivateFieldSet(this, _InnerChecker_currentHealthTimeout, null, "f");
                    // No matter what, don't start a health request if there is already one in progress.
                    // This is sane to do because receiving a response to a health request calls `update()`.
                    if (__classPrivateFieldGet(this, _InnerChecker_currentHealthCheckId, "f")) {
                        return;
                    }
                    // Actual request starting.
                    __classPrivateFieldSet(this, _InnerChecker_currentHealthCheckId, `health-checker:${__classPrivateFieldGet(this, _InnerChecker_nextRequestId, "f")}`, "f");
                    __classPrivateFieldSet(this, _InnerChecker_nextRequestId, __classPrivateFieldGet(this, _InnerChecker_nextRequestId, "f") + 1, "f");
                    __classPrivateFieldGet(this, _InnerChecker_requestToSmoldot, "f").call(this, {
                        id: __classPrivateFieldGet(this, _InnerChecker_currentHealthCheckId, "f"),
                        jsonrpc: '2.0',
                        method: 'system_health',
                        params: []
                    });
                };
                if (startNow) {
                    startHealthRequest();
                }
                else {
                    __classPrivateFieldSet(this, _InnerChecker_currentHealthTimeout, setTimeout(startHealthRequest, 1000), "f");
                }
            }
            if (__classPrivateFieldGet(this, _InnerChecker_isSyncing, "f") &&
                !__classPrivateFieldGet(this, _InnerChecker_currentSubscriptionId, "f") &&
                !__classPrivateFieldGet(this, _InnerChecker_currentSubunsubRequestId, "f")) {
                this.startSubscription();
            }
            if (!__classPrivateFieldGet(this, _InnerChecker_isSyncing, "f") &&
                __classPrivateFieldGet(this, _InnerChecker_currentSubscriptionId, "f") &&
                !__classPrivateFieldGet(this, _InnerChecker_currentSubunsubRequestId, "f")) {
                this.endSubscription();
            }
        };
        this.startSubscription = () => {
            if (__classPrivateFieldGet(this, _InnerChecker_currentSubunsubRequestId, "f") || __classPrivateFieldGet(this, _InnerChecker_currentSubscriptionId, "f")) {
                throw new Error('Internal error in health checker');
            }
            __classPrivateFieldSet(this, _InnerChecker_currentSubunsubRequestId, `health-checker:${__classPrivateFieldGet(this, _InnerChecker_nextRequestId, "f")}`, "f");
            __classPrivateFieldSet(this, _InnerChecker_nextRequestId, __classPrivateFieldGet(this, _InnerChecker_nextRequestId, "f") + 1, "f");
            __classPrivateFieldGet(this, _InnerChecker_requestToSmoldot, "f").call(this, {
                id: __classPrivateFieldGet(this, _InnerChecker_currentSubunsubRequestId, "f"),
                jsonrpc: '2.0',
                method: 'chain_subscribeNewHeads',
                params: []
            });
        };
        this.endSubscription = () => {
            if (__classPrivateFieldGet(this, _InnerChecker_currentSubunsubRequestId, "f") || !__classPrivateFieldGet(this, _InnerChecker_currentSubscriptionId, "f")) {
                throw new Error('Internal error in health checker');
            }
            __classPrivateFieldSet(this, _InnerChecker_currentSubunsubRequestId, `health-checker:${__classPrivateFieldGet(this, _InnerChecker_nextRequestId, "f")}`, "f");
            __classPrivateFieldSet(this, _InnerChecker_nextRequestId, __classPrivateFieldGet(this, _InnerChecker_nextRequestId, "f") + 1, "f");
            __classPrivateFieldGet(this, _InnerChecker_requestToSmoldot, "f").call(this, {
                id: __classPrivateFieldGet(this, _InnerChecker_currentSubunsubRequestId, "f"),
                jsonrpc: '2.0',
                method: 'chain_unsubscribeNewHeads',
                params: [__classPrivateFieldGet(this, _InnerChecker_currentSubscriptionId, "f")]
            });
        };
        this.destroy = () => {
            if (__classPrivateFieldGet(this, _InnerChecker_currentHealthTimeout, "f")) {
                clearTimeout(__classPrivateFieldGet(this, _InnerChecker_currentHealthTimeout, "f"));
                __classPrivateFieldSet(this, _InnerChecker_currentHealthTimeout, null, "f");
            }
        };
        __classPrivateFieldSet(this, _InnerChecker_healthCallback, healthCallback, "f");
        __classPrivateFieldSet(this, _InnerChecker_requestToSmoldot, (request) => requestToSmoldot(stringify(request)), "f");
    }
}
_InnerChecker_healthCallback = new WeakMap(), _InnerChecker_currentHealthCheckId = new WeakMap(), _InnerChecker_currentHealthTimeout = new WeakMap(), _InnerChecker_currentSubunsubRequestId = new WeakMap(), _InnerChecker_currentSubscriptionId = new WeakMap(), _InnerChecker_requestToSmoldot = new WeakMap(), _InnerChecker_isSyncing = new WeakMap(), _InnerChecker_nextRequestId = new WeakMap();
export class HealthCheckError extends Error {
    getCause() {
        return __classPrivateFieldGet(this, _HealthCheckError_cause, "f");
    }
    constructor(response, message = 'Got error response asking for system health') {
        super(message);
        _HealthCheckError_cause.set(this, void 0);
        __classPrivateFieldSet(this, _HealthCheckError_cause, response, "f");
    }
}
_HealthCheckError_cause = new WeakMap();
