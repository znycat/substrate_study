"use strict";
var _Vec_Type;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Vec = exports.decodeVec = void 0;
const tslib_1 = require("tslib");
const util_1 = require("@polkadot/util");
const Array_js_1 = require("../abstract/Array.js");
const index_js_1 = require("../utils/index.js");
const MAX_LENGTH = 64 * 1024;
const l = (0, util_1.logger)('Vec');
function noopSetDefinition(d) {
    return d;
}
function decodeVecLength(value) {
    if (Array.isArray(value)) {
        return [value, value.length, 0];
    }
    else if ((0, util_1.isU8a)(value) || (0, util_1.isHex)(value)) {
        const u8a = (0, util_1.u8aToU8a)(value);
        const [startAt, length] = (0, util_1.compactFromU8aLim)(u8a);
        if (length > MAX_LENGTH) {
            throw new Error(`Vec length ${length.toString()} exceeds ${MAX_LENGTH}`);
        }
        return [u8a, length, startAt];
    }
    else if (!value) {
        return [null, 0, 0];
    }
    throw new Error(`Expected array/hex input to Vec<*> decoding, found ${typeof value}: ${(0, util_1.stringify)(value)}`);
}
function decodeVec(registry, result, value, startAt, Type) {
    if (Array.isArray(value)) {
        const count = result.length;
        for (let i = 0; i < count; i++) {
            // 26/08/2022 this is actually a false positive - after recent eslint upgdates
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            const entry = value[i];
            try {
                result[i] = entry instanceof Type
                    ? entry
                    : new Type(registry, entry);
            }
            catch (error) {
                l.error(`Unable to decode on index ${i}`, error.message);
                throw error;
            }
        }
        return [0, 0];
    }
    else if (!value) {
        return [0, 0];
    }
    // we don't need more checks, we already limited it via the length decoding
    return (0, index_js_1.decodeU8aVec)(registry, result, (0, util_1.u8aToU8a)(value), startAt, Type);
}
exports.decodeVec = decodeVec;
/**
 * @name Vec
 * @description
 * This manages codec arrays. Internally it keeps track of the length (as decoded) and allows
 * construction with the passed `Type` in the constructor. It is an extension to Array, providing
 * specific encoding/decoding on top of the base type.
 */
class Vec extends Array_js_1.AbstractArray {
    constructor(registry, Type, value = [], { definition, setDefinition = noopSetDefinition } = {}) {
        const [decodeFrom, length, startAt] = decodeVecLength(value);
        super(registry, length);
        _Vec_Type.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _Vec_Type, definition || setDefinition((0, index_js_1.typeToConstructor)(registry, Type)), "f");
        this.initialU8aLength = ((0, util_1.isU8a)(decodeFrom)
            ? (0, index_js_1.decodeU8aVec)(registry, this, decodeFrom, startAt, tslib_1.__classPrivateFieldGet(this, _Vec_Type, "f"))
            : decodeVec(registry, this, decodeFrom, startAt, tslib_1.__classPrivateFieldGet(this, _Vec_Type, "f")))[0];
    }
    static with(Type) {
        let definition;
        // eslint-disable-next-line no-return-assign
        const setDefinition = (d) => (definition = d);
        return class extends Vec {
            constructor(registry, value) {
                super(registry, Type, value, { definition, setDefinition });
            }
        };
    }
    /**
     * @description The type for the items
     */
    get Type() {
        return tslib_1.__classPrivateFieldGet(this, _Vec_Type, "f").name;
    }
    /**
     * @description Finds the index of the value in the array
     */
    indexOf(_other) {
        // convert type first, this removes overhead from the eq
        const other = _other instanceof tslib_1.__classPrivateFieldGet(this, _Vec_Type, "f")
            ? _other
            : new (tslib_1.__classPrivateFieldGet(this, _Vec_Type, "f"))(this.registry, _other);
        for (let i = 0; i < this.length; i++) {
            if (other.eq(this[i])) {
                return i;
            }
        }
        return -1;
    }
    /**
     * @description Returns the base runtime type name for this instance
     */
    toRawType() {
        return `Vec<${this.registry.getClassName(tslib_1.__classPrivateFieldGet(this, _Vec_Type, "f")) || new (tslib_1.__classPrivateFieldGet(this, _Vec_Type, "f"))(this.registry).toRawType()}>`;
    }
}
exports.Vec = Vec;
_Vec_Type = new WeakMap();
