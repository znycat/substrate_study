var _TypeRegistry_chainProperties, _TypeRegistry_classes, _TypeRegistry_definitions, _TypeRegistry_firstCallIndex, _TypeRegistry_hasher, _TypeRegistry_knownTypes, _TypeRegistry_lookup, _TypeRegistry_metadata, _TypeRegistry_metadataVersion, _TypeRegistry_signedExtensions, _TypeRegistry_unknownTypes, _TypeRegistry_userExtensions, _TypeRegistry_knownDefaults, _TypeRegistry_knownDefinitions, _TypeRegistry_metadataCalls, _TypeRegistry_metadataErrors, _TypeRegistry_metadataEvents, _TypeRegistry_moduleMap, _TypeRegistry_registerObject, _TypeRegistry_registerLookup;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { DoNotConstruct, Json, Raw } from '@polkadot/types-codec';
import { constructTypeClass, createClassUnsafe, createTypeUnsafe } from '@polkadot/types-create';
import { assertReturn, BN_ZERO, formatBalance, isBn, isFunction, isNumber, isString, isU8a, lazyMethod, logger, objectSpread, stringCamelCase, stringify } from '@polkadot/util';
import { blake2AsU8a } from '@polkadot/util-crypto';
import { expandExtensionTypes, fallbackExtensions, findUnknownExtensions } from '../extrinsic/signedExtensions/index.js';
import { GenericEventData } from '../generic/Event.js';
import * as baseTypes from '../index.types.js';
import * as definitions from '../interfaces/definitions.js';
import { createCallFunction } from '../metadata/decorate/extrinsics/index.js';
import { decorateConstants, filterCallsSome, filterEventsSome } from '../metadata/decorate/index.js';
import { Metadata } from '../metadata/Metadata.js';
import { PortableRegistry } from '../metadata/PortableRegistry/index.js';
import { lazyVariants } from './lazy.js';
const DEFAULT_FIRST_CALL_IDX = new Uint8Array(2);
const l = logger('registry');
function sortDecimalStrings(a, b) {
    return parseInt(a, 10) - parseInt(b, 10);
}
function valueToString(v) {
    return v.toString();
}
function getFieldArgs(lookup, fields) {
    const args = new Array(fields.length);
    for (let i = 0; i < fields.length; i++) {
        args[i] = lookup.getTypeDef(fields[i].type).type;
    }
    return args;
}
function clearRecord(record) {
    const keys = Object.keys(record);
    for (let i = 0; i < keys.length; i++) {
        delete record[keys[i]];
    }
}
function getVariantStringIdx({ index }) {
    return index.toString();
}
function injectErrors(_, { lookup, pallets }, version, result) {
    clearRecord(result);
    for (let i = 0; i < pallets.length; i++) {
        const { errors, index, name } = pallets[i];
        if (errors.isSome) {
            const sectionName = stringCamelCase(name);
            lazyMethod(result, version >= 12 ? index.toNumber() : i, () => lazyVariants(lookup, errors.unwrap(), getVariantStringIdx, ({ docs, fields, index, name }) => ({
                args: getFieldArgs(lookup, fields),
                docs: docs.map(valueToString),
                fields,
                index: index.toNumber(),
                method: name.toString(),
                name: name.toString(),
                section: sectionName
            })));
        }
    }
}
function injectEvents(registry, { lookup, pallets }, version, result) {
    const filtered = pallets.filter(filterEventsSome);
    clearRecord(result);
    for (let i = 0; i < filtered.length; i++) {
        const { events, index, name } = filtered[i];
        lazyMethod(result, version >= 12 ? index.toNumber() : i, () => lazyVariants(lookup, events.unwrap(), getVariantStringIdx, (variant) => {
            const meta = registry.createType('EventMetadataLatest', objectSpread({}, variant, { args: getFieldArgs(lookup, variant.fields) }));
            return class extends GenericEventData {
                constructor(registry, value) {
                    super(registry, value, meta, stringCamelCase(name), variant.name.toString());
                }
            };
        }));
    }
}
function injectExtrinsics(registry, { lookup, pallets }, version, result, mapping) {
    const filtered = pallets.filter(filterCallsSome);
    clearRecord(result);
    clearRecord(mapping);
    for (let i = 0; i < filtered.length; i++) {
        const { calls, index, name } = filtered[i];
        const sectionIndex = version >= 12 ? index.toNumber() : i;
        const sectionName = stringCamelCase(name);
        const allCalls = calls.unwrap();
        lazyMethod(result, sectionIndex, () => lazyVariants(lookup, allCalls, getVariantStringIdx, (variant) => createCallFunction(registry, lookup, variant, sectionName, sectionIndex)));
        const { path } = registry.lookup.getSiType(allCalls.type);
        // frame_system::pallet::Call / pallet_balances::pallet::Call / polkadot_runtime_parachains::configuration::pallet::Call /
        const palletIdx = path.findIndex((v) => v.eq('pallet'));
        if (palletIdx !== -1) {
            const name = stringCamelCase(path
                .slice(0, palletIdx)
                .map((p, i) => i === 0
                // frame_system || pallet_balances
                ? p.replace(/^(frame|pallet)_/, '')
                : p)
                .join(' '));
            if (!mapping[name]) {
                mapping[name] = [sectionName];
            }
            else {
                mapping[name].push(sectionName);
            }
        }
    }
}
function extractProperties(registry, metadata) {
    const original = registry.getChainProperties();
    const constants = decorateConstants(registry, metadata.asLatest, metadata.version);
    const ss58Format = constants.system && (constants.system.sS58Prefix || constants.system.ss58Prefix);
    if (!ss58Format) {
        return original;
    }
    const { tokenDecimals, tokenSymbol } = original || {};
    return registry.createTypeUnsafe('ChainProperties', [{ ss58Format, tokenDecimals, tokenSymbol }]);
}
export class TypeRegistry {
    constructor(createdAtHash) {
        _TypeRegistry_chainProperties.set(this, void 0);
        _TypeRegistry_classes.set(this, new Map());
        _TypeRegistry_definitions.set(this, new Map());
        _TypeRegistry_firstCallIndex.set(this, null);
        _TypeRegistry_hasher.set(this, blake2AsU8a);
        _TypeRegistry_knownTypes.set(this, {});
        _TypeRegistry_lookup.set(this, void 0);
        _TypeRegistry_metadata.set(this, void 0);
        _TypeRegistry_metadataVersion.set(this, 0);
        _TypeRegistry_signedExtensions.set(this, fallbackExtensions);
        _TypeRegistry_unknownTypes.set(this, new Map());
        _TypeRegistry_userExtensions.set(this, void 0);
        _TypeRegistry_knownDefaults.set(this, void 0);
        _TypeRegistry_knownDefinitions.set(this, void 0);
        _TypeRegistry_metadataCalls.set(this, {});
        _TypeRegistry_metadataErrors.set(this, {});
        _TypeRegistry_metadataEvents.set(this, {});
        _TypeRegistry_moduleMap.set(this, {});
        _TypeRegistry_registerObject.set(this, (obj) => {
            const entries = Object.entries(obj);
            for (let e = 0; e < entries.length; e++) {
                const [name, type] = entries[e];
                if (isFunction(type)) {
                    // This _looks_ a bit funny, but `typeof Clazz === 'function'
                    __classPrivateFieldGet(this, _TypeRegistry_classes, "f").set(name, type);
                }
                else {
                    const def = isString(type)
                        ? type
                        : stringify(type);
                    if (name === def) {
                        throw new Error(`Unable to register circular ${name} === ${def}`);
                    }
                    // we already have this type, remove the classes registered for it
                    if (__classPrivateFieldGet(this, _TypeRegistry_classes, "f").has(name)) {
                        __classPrivateFieldGet(this, _TypeRegistry_classes, "f").delete(name);
                    }
                    __classPrivateFieldGet(this, _TypeRegistry_definitions, "f").set(name, def);
                }
            }
        });
        // register alias types alongside the portable/lookup setup
        // (we don't combine this into setLookup since that would/could
        // affect stand-along lookups, such as ABIs which don't have
        // actual on-chain metadata)
        _TypeRegistry_registerLookup.set(this, (lookup) => {
            // attach the lookup before we register any types
            this.setLookup(lookup);
            // we detect based on runtime configuration
            let Weight = null;
            if (this.hasType('SpWeightsWeightV2Weight')) {
                // detection for WeightV2 type based on latest naming
                const weightv2 = this.createType('SpWeightsWeightV2Weight');
                Weight = weightv2.refTime && weightv2.proofSize
                    // with both refTime & proofSize we use as-is (WeightV2)
                    ? 'SpWeightsWeightV2Weight'
                    // fallback to WeightV1 (WeightV1.5 is a struct, single field)
                    : 'WeightV1';
            }
            else if (!isBn(this.createType('Weight'))) {
                // where we have an already-supplied BN override, we don't clobber
                // it with our detected value (This protects against pre-defines
                // where Weight may be aliassed to WeightV0, e.g. in early Kusama chains)
                Weight = 'WeightV1';
            }
            if (Weight) {
                // we have detected a version, adjust the definition
                this.register({ Weight });
            }
        });
        __classPrivateFieldSet(this, _TypeRegistry_knownDefaults, objectSpread({ Json, Metadata, PortableRegistry, Raw }, baseTypes), "f");
        __classPrivateFieldSet(this, _TypeRegistry_knownDefinitions, definitions, "f");
        const allKnown = Object.values(__classPrivateFieldGet(this, _TypeRegistry_knownDefinitions, "f"));
        for (let i = 0; i < allKnown.length; i++) {
            this.register(allKnown[i].types);
        }
        if (createdAtHash) {
            this.createdAtHash = this.createType('BlockHash', createdAtHash);
        }
    }
    get chainDecimals() {
        if (__classPrivateFieldGet(this, _TypeRegistry_chainProperties, "f")?.tokenDecimals.isSome) {
            const allDecimals = __classPrivateFieldGet(this, _TypeRegistry_chainProperties, "f").tokenDecimals.unwrap();
            if (allDecimals.length) {
                return allDecimals.map((b) => b.toNumber());
            }
        }
        return [12];
    }
    get chainSS58() {
        return __classPrivateFieldGet(this, _TypeRegistry_chainProperties, "f")?.ss58Format.isSome
            ? __classPrivateFieldGet(this, _TypeRegistry_chainProperties, "f").ss58Format.unwrap().toNumber()
            : undefined;
    }
    get chainTokens() {
        if (__classPrivateFieldGet(this, _TypeRegistry_chainProperties, "f")?.tokenSymbol.isSome) {
            const allTokens = __classPrivateFieldGet(this, _TypeRegistry_chainProperties, "f").tokenSymbol.unwrap();
            if (allTokens.length) {
                return allTokens.map(valueToString);
            }
        }
        return [formatBalance.getDefaults().unit];
    }
    get firstCallIndex() {
        return __classPrivateFieldGet(this, _TypeRegistry_firstCallIndex, "f") || DEFAULT_FIRST_CALL_IDX;
    }
    /**
     * @description Returns true if the type is in a Compat format
     */
    isLookupType(value) {
        return /Lookup\d+$/.test(value);
    }
    /**
     * @description Creates a lookup string from the supplied id
     */
    createLookupType(lookupId) {
        return `Lookup${typeof lookupId === 'number' ? lookupId : lookupId.toNumber()}`;
    }
    get knownTypes() {
        return __classPrivateFieldGet(this, _TypeRegistry_knownTypes, "f");
    }
    get lookup() {
        return assertReturn(__classPrivateFieldGet(this, _TypeRegistry_lookup, "f"), 'PortableRegistry has not been set on this registry');
    }
    get metadata() {
        return assertReturn(__classPrivateFieldGet(this, _TypeRegistry_metadata, "f"), 'Metadata has not been set on this registry');
    }
    get unknownTypes() {
        return [...__classPrivateFieldGet(this, _TypeRegistry_unknownTypes, "f").keys()];
    }
    get signedExtensions() {
        return __classPrivateFieldGet(this, _TypeRegistry_signedExtensions, "f");
    }
    clearCache() {
        __classPrivateFieldSet(this, _TypeRegistry_classes, new Map(), "f");
    }
    /**
     * @describe Creates an instance of the class
     */
    createClass(type) {
        return createClassUnsafe(this, type);
    }
    /**
     * @describe Creates an instance of the class
     */
    createClassUnsafe(type) {
        return createClassUnsafe(this, type);
    }
    /**
     * @description Creates an instance of a type as registered
     */
    createType(type, ...params) {
        return createTypeUnsafe(this, type, params);
    }
    /**
     * @description Creates an instance of a type as registered
     */
    createTypeUnsafe(type, params, options) {
        return createTypeUnsafe(this, type, params, options);
    }
    // find a specific call
    findMetaCall(callIndex) {
        const [section, method] = [callIndex[0], callIndex[1]];
        return assertReturn(__classPrivateFieldGet(this, _TypeRegistry_metadataCalls, "f")[`${section}`] && __classPrivateFieldGet(this, _TypeRegistry_metadataCalls, "f")[`${section}`][`${method}`], () => `findMetaCall: Unable to find Call with index [${section}, ${method}]/[${callIndex.toString()}]`);
    }
    // finds an error
    findMetaError(errorIndex) {
        const [section, method] = isU8a(errorIndex)
            ? [errorIndex[0], errorIndex[1]]
            : [
                errorIndex.index.toNumber(),
                isU8a(errorIndex.error)
                    ? errorIndex.error[0]
                    : errorIndex.error.toNumber()
            ];
        return assertReturn(__classPrivateFieldGet(this, _TypeRegistry_metadataErrors, "f")[`${section}`] && __classPrivateFieldGet(this, _TypeRegistry_metadataErrors, "f")[`${section}`][`${method}`], () => `findMetaError: Unable to find Error with index [${section}, ${method}]/[${errorIndex.toString()}]`);
    }
    findMetaEvent(eventIndex) {
        const [section, method] = [eventIndex[0], eventIndex[1]];
        return assertReturn(__classPrivateFieldGet(this, _TypeRegistry_metadataEvents, "f")[`${section}`] && __classPrivateFieldGet(this, _TypeRegistry_metadataEvents, "f")[`${section}`][`${method}`], () => `findMetaEvent: Unable to find Event with index [${section}, ${method}]/[${eventIndex.toString()}]`);
    }
    get(name, withUnknown, knownTypeDef) {
        return this.getUnsafe(name, withUnknown, knownTypeDef);
    }
    getUnsafe(name, withUnknown, knownTypeDef) {
        let Type = __classPrivateFieldGet(this, _TypeRegistry_classes, "f").get(name) || __classPrivateFieldGet(this, _TypeRegistry_knownDefaults, "f")[name];
        // we have not already created the type, attempt it
        if (!Type) {
            const definition = __classPrivateFieldGet(this, _TypeRegistry_definitions, "f").get(name);
            let BaseType;
            // we have a definition, so create the class now (lazily)
            if (definition) {
                BaseType = createClassUnsafe(this, definition);
            }
            else if (knownTypeDef) {
                BaseType = constructTypeClass(this, knownTypeDef);
            }
            else if (withUnknown) {
                l.warn(`Unable to resolve type ${name}, it will fail on construction`);
                __classPrivateFieldGet(this, _TypeRegistry_unknownTypes, "f").set(name, true);
                BaseType = DoNotConstruct.with(name);
            }
            if (BaseType) {
                // NOTE If we didn't extend here, we would have strange artifacts. An example is
                // Balance, with this, new Balance() instanceof u128 is true, but Balance !== u128
                // Additionally, we now pass through the registry, which is a link to ourselves
                Type = class extends BaseType {
                };
                __classPrivateFieldGet(this, _TypeRegistry_classes, "f").set(name, Type);
                // In the case of lookups, we also want to store the actual class against
                // the lookup name, instad of having to traverse again
                if (knownTypeDef && isNumber(knownTypeDef.lookupIndex)) {
                    __classPrivateFieldGet(this, _TypeRegistry_classes, "f").set(this.createLookupType(knownTypeDef.lookupIndex), Type);
                }
            }
        }
        return Type;
    }
    getChainProperties() {
        return __classPrivateFieldGet(this, _TypeRegistry_chainProperties, "f");
    }
    getClassName(Type) {
        // we cannot rely on export order (anymore, since babel/core 7.15.8), so in the case of
        // items such as u32 & U32, we get the lowercase versions here... not quite as optimal
        // (previously this used to be a simple find & return)
        const names = [];
        for (const [name, Clazz] of Object.entries(__classPrivateFieldGet(this, _TypeRegistry_knownDefaults, "f"))) {
            if (Type === Clazz) {
                names.push(name);
            }
        }
        for (const [name, Clazz] of __classPrivateFieldGet(this, _TypeRegistry_classes, "f").entries()) {
            if (Type === Clazz) {
                names.push(name);
            }
        }
        // both sort and reverse are done in-place
        names.sort().reverse();
        return names.length
            ? names[0]
            : undefined;
    }
    getDefinition(typeName) {
        return __classPrivateFieldGet(this, _TypeRegistry_definitions, "f").get(typeName);
    }
    getModuleInstances(specName, moduleName) {
        return __classPrivateFieldGet(this, _TypeRegistry_knownTypes, "f")?.typesBundle?.spec?.[specName.toString()]?.instances?.[moduleName] || __classPrivateFieldGet(this, _TypeRegistry_moduleMap, "f")[moduleName];
    }
    getOrThrow(name) {
        const Clazz = this.get(name);
        if (!Clazz) {
            throw new Error(`type ${name} not found`);
        }
        return Clazz;
    }
    getOrUnknown(name) {
        return this.get(name, true);
    }
    getSignedExtensionExtra() {
        return expandExtensionTypes(__classPrivateFieldGet(this, _TypeRegistry_signedExtensions, "f"), 'payload', __classPrivateFieldGet(this, _TypeRegistry_userExtensions, "f"));
    }
    getSignedExtensionTypes() {
        return expandExtensionTypes(__classPrivateFieldGet(this, _TypeRegistry_signedExtensions, "f"), 'extrinsic', __classPrivateFieldGet(this, _TypeRegistry_userExtensions, "f"));
    }
    hasClass(name) {
        return __classPrivateFieldGet(this, _TypeRegistry_classes, "f").has(name) || !!__classPrivateFieldGet(this, _TypeRegistry_knownDefaults, "f")[name];
    }
    hasDef(name) {
        return __classPrivateFieldGet(this, _TypeRegistry_definitions, "f").has(name);
    }
    hasType(name) {
        return !__classPrivateFieldGet(this, _TypeRegistry_unknownTypes, "f").get(name) && (this.hasClass(name) || this.hasDef(name));
    }
    hash(data) {
        return this.createType('CodecHash', __classPrivateFieldGet(this, _TypeRegistry_hasher, "f").call(this, data));
    }
    // eslint-disable-next-line no-dupe-class-members
    register(arg1, arg2) {
        // NOTE Constructors appear as functions here
        if (isFunction(arg1)) {
            __classPrivateFieldGet(this, _TypeRegistry_classes, "f").set(arg1.name, arg1);
        }
        else if (isString(arg1)) {
            if (!isFunction(arg2)) {
                throw new Error(`Expected class definition passed to '${arg1}' registration`);
            }
            else if (arg1 === arg2.toString()) {
                throw new Error(`Unable to register circular ${arg1} === ${arg1}`);
            }
            __classPrivateFieldGet(this, _TypeRegistry_classes, "f").set(arg1, arg2);
        }
        else {
            __classPrivateFieldGet(this, _TypeRegistry_registerObject, "f").call(this, arg1);
        }
    }
    // sets the chain properties
    setChainProperties(properties) {
        if (properties) {
            __classPrivateFieldSet(this, _TypeRegistry_chainProperties, properties, "f");
        }
    }
    setHasher(hasher) {
        __classPrivateFieldSet(this, _TypeRegistry_hasher, hasher || blake2AsU8a, "f");
    }
    setKnownTypes(knownTypes) {
        __classPrivateFieldSet(this, _TypeRegistry_knownTypes, knownTypes, "f");
    }
    setLookup(lookup) {
        __classPrivateFieldSet(this, _TypeRegistry_lookup, lookup, "f");
        // register all applicable types found
        lookup.register();
    }
    // sets the metadata
    setMetadata(metadata, signedExtensions, userExtensions) {
        __classPrivateFieldSet(this, _TypeRegistry_metadata, metadata.asLatest, "f");
        __classPrivateFieldSet(this, _TypeRegistry_metadataVersion, metadata.version, "f");
        __classPrivateFieldSet(this, _TypeRegistry_firstCallIndex, null, "f");
        // attach the lookup at this point and register relevant types (before injecting)
        __classPrivateFieldGet(this, _TypeRegistry_registerLookup, "f").call(this, __classPrivateFieldGet(this, _TypeRegistry_metadata, "f").lookup);
        injectExtrinsics(this, __classPrivateFieldGet(this, _TypeRegistry_metadata, "f"), __classPrivateFieldGet(this, _TypeRegistry_metadataVersion, "f"), __classPrivateFieldGet(this, _TypeRegistry_metadataCalls, "f"), __classPrivateFieldGet(this, _TypeRegistry_moduleMap, "f"));
        injectErrors(this, __classPrivateFieldGet(this, _TypeRegistry_metadata, "f"), __classPrivateFieldGet(this, _TypeRegistry_metadataVersion, "f"), __classPrivateFieldGet(this, _TypeRegistry_metadataErrors, "f"));
        injectEvents(this, __classPrivateFieldGet(this, _TypeRegistry_metadata, "f"), __classPrivateFieldGet(this, _TypeRegistry_metadataVersion, "f"), __classPrivateFieldGet(this, _TypeRegistry_metadataEvents, "f"));
        // set the default call index (the lowest section, the lowest method)
        // in most chains this should be 0,0
        const [defSection] = Object
            .keys(__classPrivateFieldGet(this, _TypeRegistry_metadataCalls, "f"))
            .sort(sortDecimalStrings);
        if (defSection) {
            const [defMethod] = Object
                .keys(__classPrivateFieldGet(this, _TypeRegistry_metadataCalls, "f")[defSection])
                .sort(sortDecimalStrings);
            if (defMethod) {
                __classPrivateFieldSet(this, _TypeRegistry_firstCallIndex, new Uint8Array([parseInt(defSection, 10), parseInt(defMethod, 10)]), "f");
            }
        }
        // setup the available extensions
        this.setSignedExtensions(signedExtensions || (__classPrivateFieldGet(this, _TypeRegistry_metadata, "f").extrinsic.version.gt(BN_ZERO)
            // FIXME Use the extension and their injected types
            ? __classPrivateFieldGet(this, _TypeRegistry_metadata, "f").extrinsic.signedExtensions.map(({ identifier }) => identifier.toString())
            : fallbackExtensions), userExtensions);
        // setup the chain properties with format overrides
        this.setChainProperties(extractProperties(this, metadata));
    }
    // sets the available signed extensions
    setSignedExtensions(signedExtensions = fallbackExtensions, userExtensions) {
        __classPrivateFieldSet(this, _TypeRegistry_signedExtensions, signedExtensions, "f");
        __classPrivateFieldSet(this, _TypeRegistry_userExtensions, userExtensions, "f");
        const unknown = findUnknownExtensions(__classPrivateFieldGet(this, _TypeRegistry_signedExtensions, "f"), __classPrivateFieldGet(this, _TypeRegistry_userExtensions, "f"));
        if (unknown.length) {
            l.warn(`Unknown signed extensions ${unknown.join(', ')} found, treating them as no-effect`);
        }
    }
}
_TypeRegistry_chainProperties = new WeakMap(), _TypeRegistry_classes = new WeakMap(), _TypeRegistry_definitions = new WeakMap(), _TypeRegistry_firstCallIndex = new WeakMap(), _TypeRegistry_hasher = new WeakMap(), _TypeRegistry_knownTypes = new WeakMap(), _TypeRegistry_lookup = new WeakMap(), _TypeRegistry_metadata = new WeakMap(), _TypeRegistry_metadataVersion = new WeakMap(), _TypeRegistry_signedExtensions = new WeakMap(), _TypeRegistry_unknownTypes = new WeakMap(), _TypeRegistry_userExtensions = new WeakMap(), _TypeRegistry_knownDefaults = new WeakMap(), _TypeRegistry_knownDefinitions = new WeakMap(), _TypeRegistry_metadataCalls = new WeakMap(), _TypeRegistry_metadataErrors = new WeakMap(), _TypeRegistry_metadataEvents = new WeakMap(), _TypeRegistry_moduleMap = new WeakMap(), _TypeRegistry_registerObject = new WeakMap(), _TypeRegistry_registerLookup = new WeakMap();
