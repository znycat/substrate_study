"use strict";
var _WsProvider_instances, _WsProvider_callCache, _WsProvider_coder, _WsProvider_endpoints, _WsProvider_headers, _WsProvider_eventemitter, _WsProvider_handlers, _WsProvider_isReadyPromise, _WsProvider_stats, _WsProvider_waitingForId, _WsProvider_autoConnectMs, _WsProvider_endpointIndex, _WsProvider_endpointStats, _WsProvider_isConnected, _WsProvider_subscriptions, _WsProvider_timeoutId, _WsProvider_websocket, _WsProvider_timeout, _WsProvider_send, _WsProvider_emit, _WsProvider_onSocketClose, _WsProvider_onSocketError, _WsProvider_onSocketMessage, _WsProvider_onSocketMessageResult, _WsProvider_onSocketMessageSubscribe, _WsProvider_onSocketOpen, _WsProvider_resubscribe, _WsProvider_timeoutHandlers;
Object.defineProperty(exports, "__esModule", { value: true });
exports.WsProvider = void 0;
const tslib_1 = require("tslib");
const eventemitter3_1 = require("eventemitter3");
const util_1 = require("@polkadot/util");
const x_global_1 = require("@polkadot/x-global");
const x_ws_1 = require("@polkadot/x-ws");
const index_js_1 = require("../coder/index.js");
const defaults_js_1 = tslib_1.__importDefault(require("../defaults.js"));
const lru_js_1 = require("../lru.js");
const errors_js_1 = require("./errors.js");
const ALIASES = {
    chain_finalisedHead: 'chain_finalizedHead',
    chain_subscribeFinalisedHeads: 'chain_subscribeFinalizedHeads',
    chain_unsubscribeFinalisedHeads: 'chain_unsubscribeFinalizedHeads'
};
const RETRY_DELAY = 2500;
const DEFAULT_TIMEOUT_MS = 60 * 1000;
const TIMEOUT_INTERVAL = 5000;
const l = (0, util_1.logger)('api-ws');
/** @internal Clears a Record<*> of all keys, optionally with all callback on clear */
function eraseRecord(record, cb) {
    Object.keys(record).forEach((key) => {
        if (cb) {
            cb(record[key]);
        }
        delete record[key];
    });
}
/** @internal Creates a default/empty stats object */
function defaultEndpointStats() {
    return { bytesRecv: 0, bytesSent: 0, cached: 0, errors: 0, requests: 0, subscriptions: 0, timeout: 0 };
}
/**
 * # @polkadot/rpc-provider/ws
 *
 * @name WsProvider
 *
 * @description The WebSocket Provider allows sending requests using WebSocket to a WebSocket RPC server TCP port. Unlike the [[HttpProvider]], it does support subscriptions and allows listening to events such as new blocks or balance changes.
 *
 * @example
 * <BR>
 *
 * ```javascript
 * import Api from '@polkadot/api/promise';
 * import { WsProvider } from '@polkadot/rpc-provider/ws';
 *
 * const provider = new WsProvider('ws://127.0.0.1:9944');
 * const api = new Api(provider);
 * ```
 *
 * @see [[HttpProvider]]
 */
class WsProvider {
    /**
     * @param {string | string[]}  endpoint    The endpoint url. Usually `ws://ip:9944` or `wss://ip:9944`, may provide an array of endpoint strings.
     * @param {number | false} autoConnectMs Whether to connect automatically or not (default). Provided value is used as a delay between retries.
     * @param {Record<string, string>} headers The headers provided to the underlying WebSocket
     * @param {number} [timeout] Custom timeout value used per request . Defaults to `DEFAULT_TIMEOUT_MS`
     */
    constructor(endpoint = defaults_js_1.default.WS_URL, autoConnectMs = RETRY_DELAY, headers = {}, timeout) {
        _WsProvider_instances.add(this);
        _WsProvider_callCache.set(this, new lru_js_1.LRUCache());
        _WsProvider_coder.set(this, void 0);
        _WsProvider_endpoints.set(this, void 0);
        _WsProvider_headers.set(this, void 0);
        _WsProvider_eventemitter.set(this, void 0);
        _WsProvider_handlers.set(this, {});
        _WsProvider_isReadyPromise.set(this, void 0);
        _WsProvider_stats.set(this, void 0);
        _WsProvider_waitingForId.set(this, {});
        _WsProvider_autoConnectMs.set(this, void 0);
        _WsProvider_endpointIndex.set(this, void 0);
        _WsProvider_endpointStats.set(this, void 0);
        _WsProvider_isConnected.set(this, false);
        _WsProvider_subscriptions.set(this, {});
        _WsProvider_timeoutId.set(this, null);
        _WsProvider_websocket.set(this, void 0);
        _WsProvider_timeout.set(this, void 0);
        _WsProvider_emit.set(this, (type, ...args) => {
            tslib_1.__classPrivateFieldGet(this, _WsProvider_eventemitter, "f").emit(type, ...args);
        });
        _WsProvider_onSocketClose.set(this, (event) => {
            const error = new Error(`disconnected from ${this.endpoint}: ${event.code}:: ${event.reason || (0, errors_js_1.getWSErrorString)(event.code)}`);
            if (tslib_1.__classPrivateFieldGet(this, _WsProvider_autoConnectMs, "f") > 0) {
                l.error(error.message);
            }
            tslib_1.__classPrivateFieldSet(this, _WsProvider_isConnected, false, "f");
            if (tslib_1.__classPrivateFieldGet(this, _WsProvider_websocket, "f")) {
                tslib_1.__classPrivateFieldGet(this, _WsProvider_websocket, "f").onclose = null;
                tslib_1.__classPrivateFieldGet(this, _WsProvider_websocket, "f").onerror = null;
                tslib_1.__classPrivateFieldGet(this, _WsProvider_websocket, "f").onmessage = null;
                tslib_1.__classPrivateFieldGet(this, _WsProvider_websocket, "f").onopen = null;
                tslib_1.__classPrivateFieldSet(this, _WsProvider_websocket, null, "f");
            }
            if (tslib_1.__classPrivateFieldGet(this, _WsProvider_timeoutId, "f")) {
                clearInterval(tslib_1.__classPrivateFieldGet(this, _WsProvider_timeoutId, "f"));
                tslib_1.__classPrivateFieldSet(this, _WsProvider_timeoutId, null, "f");
            }
            // reject all hanging requests
            eraseRecord(tslib_1.__classPrivateFieldGet(this, _WsProvider_handlers, "f"), (h) => {
                try {
                    h.callback(error, undefined);
                }
                catch (err) {
                    // does not throw
                    l.error(err);
                }
            });
            eraseRecord(tslib_1.__classPrivateFieldGet(this, _WsProvider_waitingForId, "f"));
            // Reset stats for active endpoint
            tslib_1.__classPrivateFieldSet(this, _WsProvider_endpointStats, defaultEndpointStats(), "f");
            tslib_1.__classPrivateFieldGet(this, _WsProvider_emit, "f").call(this, 'disconnected');
            if (tslib_1.__classPrivateFieldGet(this, _WsProvider_autoConnectMs, "f") > 0) {
                setTimeout(() => {
                    this.connectWithRetry().catch(() => {
                        // does not throw
                    });
                }, tslib_1.__classPrivateFieldGet(this, _WsProvider_autoConnectMs, "f"));
            }
        });
        _WsProvider_onSocketError.set(this, (error) => {
            l.debug(() => ['socket error', error]);
            tslib_1.__classPrivateFieldGet(this, _WsProvider_emit, "f").call(this, 'error', error);
        });
        _WsProvider_onSocketMessage.set(this, (message) => {
            l.debug(() => ['received', message.data]);
            tslib_1.__classPrivateFieldGet(this, _WsProvider_endpointStats, "f").bytesRecv += message.data.length;
            tslib_1.__classPrivateFieldGet(this, _WsProvider_stats, "f").total.bytesRecv += message.data.length;
            const response = JSON.parse(message.data);
            return (0, util_1.isUndefined)(response.method)
                ? tslib_1.__classPrivateFieldGet(this, _WsProvider_onSocketMessageResult, "f").call(this, response)
                : tslib_1.__classPrivateFieldGet(this, _WsProvider_onSocketMessageSubscribe, "f").call(this, response);
        });
        _WsProvider_onSocketMessageResult.set(this, (response) => {
            const handler = tslib_1.__classPrivateFieldGet(this, _WsProvider_handlers, "f")[response.id];
            if (!handler) {
                l.debug(() => `Unable to find handler for id=${response.id}`);
                return;
            }
            try {
                const { method, params, subscription } = handler;
                const result = tslib_1.__classPrivateFieldGet(this, _WsProvider_coder, "f").decodeResponse(response);
                // first send the result - in case of subs, we may have an update
                // immediately if we have some queued results already
                handler.callback(null, result);
                if (subscription) {
                    const subId = `${subscription.type}::${result}`;
                    tslib_1.__classPrivateFieldGet(this, _WsProvider_subscriptions, "f")[subId] = (0, util_1.objectSpread)({}, subscription, {
                        method,
                        params
                    });
                    // if we have a result waiting for this subscription already
                    if (tslib_1.__classPrivateFieldGet(this, _WsProvider_waitingForId, "f")[subId]) {
                        tslib_1.__classPrivateFieldGet(this, _WsProvider_onSocketMessageSubscribe, "f").call(this, tslib_1.__classPrivateFieldGet(this, _WsProvider_waitingForId, "f")[subId]);
                    }
                }
            }
            catch (error) {
                tslib_1.__classPrivateFieldGet(this, _WsProvider_endpointStats, "f").errors++;
                tslib_1.__classPrivateFieldGet(this, _WsProvider_stats, "f").total.errors++;
                handler.callback(error, undefined);
            }
            delete tslib_1.__classPrivateFieldGet(this, _WsProvider_handlers, "f")[response.id];
        });
        _WsProvider_onSocketMessageSubscribe.set(this, (response) => {
            const method = ALIASES[response.method] || response.method || 'invalid';
            const subId = `${method}::${response.params.subscription}`;
            const handler = tslib_1.__classPrivateFieldGet(this, _WsProvider_subscriptions, "f")[subId];
            if (!handler) {
                // store the JSON, we could have out-of-order subid coming in
                tslib_1.__classPrivateFieldGet(this, _WsProvider_waitingForId, "f")[subId] = response;
                l.debug(() => `Unable to find handler for subscription=${subId}`);
                return;
            }
            // housekeeping
            delete tslib_1.__classPrivateFieldGet(this, _WsProvider_waitingForId, "f")[subId];
            try {
                const result = tslib_1.__classPrivateFieldGet(this, _WsProvider_coder, "f").decodeResponse(response);
                handler.callback(null, result);
            }
            catch (error) {
                tslib_1.__classPrivateFieldGet(this, _WsProvider_endpointStats, "f").errors++;
                tslib_1.__classPrivateFieldGet(this, _WsProvider_stats, "f").total.errors++;
                handler.callback(error, undefined);
            }
        });
        _WsProvider_onSocketOpen.set(this, () => {
            if (tslib_1.__classPrivateFieldGet(this, _WsProvider_websocket, "f") === null) {
                throw new Error('WebSocket cannot be null in onOpen');
            }
            l.debug(() => ['connected to', this.endpoint]);
            tslib_1.__classPrivateFieldSet(this, _WsProvider_isConnected, true, "f");
            tslib_1.__classPrivateFieldGet(this, _WsProvider_resubscribe, "f").call(this);
            tslib_1.__classPrivateFieldGet(this, _WsProvider_emit, "f").call(this, 'connected');
            return true;
        });
        _WsProvider_resubscribe.set(this, () => {
            const subscriptions = tslib_1.__classPrivateFieldGet(this, _WsProvider_subscriptions, "f");
            tslib_1.__classPrivateFieldSet(this, _WsProvider_subscriptions, {}, "f");
            Promise.all(Object.keys(subscriptions).map(async (id) => {
                const { callback, method, params, type } = subscriptions[id];
                // only re-create subscriptions which are not in author (only area where
                // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'
                // are not included (and will not be re-broadcast)
                if (type.startsWith('author_')) {
                    return;
                }
                try {
                    await this.subscribe(type, method, params, callback);
                }
                catch (error) {
                    l.error(error);
                }
            })).catch(l.error);
        });
        _WsProvider_timeoutHandlers.set(this, () => {
            const now = Date.now();
            const ids = Object.keys(tslib_1.__classPrivateFieldGet(this, _WsProvider_handlers, "f"));
            for (let i = 0; i < ids.length; i++) {
                const handler = tslib_1.__classPrivateFieldGet(this, _WsProvider_handlers, "f")[ids[i]];
                if ((now - handler.start) > tslib_1.__classPrivateFieldGet(this, _WsProvider_timeout, "f")) {
                    try {
                        handler.callback(new Error(`No response received from RPC endpoint in ${tslib_1.__classPrivateFieldGet(this, _WsProvider_timeout, "f") / 1000}s`), undefined);
                    }
                    catch {
                        // ignore
                    }
                    tslib_1.__classPrivateFieldGet(this, _WsProvider_endpointStats, "f").timeout++;
                    tslib_1.__classPrivateFieldGet(this, _WsProvider_stats, "f").total.timeout++;
                    delete tslib_1.__classPrivateFieldGet(this, _WsProvider_handlers, "f")[ids[i]];
                }
            }
        });
        const endpoints = Array.isArray(endpoint)
            ? endpoint
            : [endpoint];
        if (endpoints.length === 0) {
            throw new Error('WsProvider requires at least one Endpoint');
        }
        endpoints.forEach((endpoint) => {
            if (!/^(wss|ws):\/\//.test(endpoint)) {
                throw new Error(`Endpoint should start with 'ws://', received '${endpoint}'`);
            }
        });
        tslib_1.__classPrivateFieldSet(this, _WsProvider_eventemitter, new eventemitter3_1.EventEmitter(), "f");
        tslib_1.__classPrivateFieldSet(this, _WsProvider_autoConnectMs, autoConnectMs || 0, "f");
        tslib_1.__classPrivateFieldSet(this, _WsProvider_coder, new index_js_1.RpcCoder(), "f");
        tslib_1.__classPrivateFieldSet(this, _WsProvider_endpointIndex, -1, "f");
        tslib_1.__classPrivateFieldSet(this, _WsProvider_endpoints, endpoints, "f");
        tslib_1.__classPrivateFieldSet(this, _WsProvider_headers, headers, "f");
        tslib_1.__classPrivateFieldSet(this, _WsProvider_websocket, null, "f");
        tslib_1.__classPrivateFieldSet(this, _WsProvider_stats, {
            active: { requests: 0, subscriptions: 0 },
            total: defaultEndpointStats()
        }, "f");
        tslib_1.__classPrivateFieldSet(this, _WsProvider_endpointStats, defaultEndpointStats(), "f");
        tslib_1.__classPrivateFieldSet(this, _WsProvider_timeout, timeout || DEFAULT_TIMEOUT_MS, "f");
        if (autoConnectMs > 0) {
            this.connectWithRetry().catch(() => {
                // does not throw
            });
        }
        tslib_1.__classPrivateFieldSet(this, _WsProvider_isReadyPromise, new Promise((resolve) => {
            tslib_1.__classPrivateFieldGet(this, _WsProvider_eventemitter, "f").once('connected', () => {
                resolve(this);
            });
        }), "f");
    }
    /**
     * @summary `true` when this provider supports subscriptions
     */
    get hasSubscriptions() {
        return true;
    }
    /**
     * @summary `true` when this provider supports clone()
     */
    get isClonable() {
        return true;
    }
    /**
     * @summary Whether the node is connected or not.
     * @return {boolean} true if connected
     */
    get isConnected() {
        return tslib_1.__classPrivateFieldGet(this, _WsProvider_isConnected, "f");
    }
    /**
     * @description Promise that resolves the first time we are connected and loaded
     */
    get isReady() {
        return tslib_1.__classPrivateFieldGet(this, _WsProvider_isReadyPromise, "f");
    }
    get endpoint() {
        return tslib_1.__classPrivateFieldGet(this, _WsProvider_endpoints, "f")[tslib_1.__classPrivateFieldGet(this, _WsProvider_endpointIndex, "f")];
    }
    /**
     * @description Returns a clone of the object
     */
    clone() {
        return new WsProvider(tslib_1.__classPrivateFieldGet(this, _WsProvider_endpoints, "f"));
    }
    selectEndpointIndex(endpoints) {
        return (tslib_1.__classPrivateFieldGet(this, _WsProvider_endpointIndex, "f") + 1) % endpoints.length;
    }
    /**
     * @summary Manually connect
     * @description The [[WsProvider]] connects automatically by default, however if you decided otherwise, you may
     * connect manually using this method.
     */
    // eslint-disable-next-line @typescript-eslint/require-await
    async connect() {
        if (tslib_1.__classPrivateFieldGet(this, _WsProvider_websocket, "f")) {
            throw new Error('WebSocket is already connected');
        }
        try {
            tslib_1.__classPrivateFieldSet(this, _WsProvider_endpointIndex, this.selectEndpointIndex(tslib_1.__classPrivateFieldGet(this, _WsProvider_endpoints, "f")), "f");
            // the as typeof WebSocket here is Deno-specific - not available on the globalThis
            tslib_1.__classPrivateFieldSet(this, _WsProvider_websocket, typeof x_global_1.xglobal.WebSocket !== 'undefined' && (0, util_1.isChildClass)(x_global_1.xglobal.WebSocket, x_ws_1.WebSocket)
                ? new x_ws_1.WebSocket(this.endpoint)
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore - WS may be an instance of ws, which supports options
                : new x_ws_1.WebSocket(this.endpoint, undefined, {
                    headers: tslib_1.__classPrivateFieldGet(this, _WsProvider_headers, "f")
                }), "f");
            if (tslib_1.__classPrivateFieldGet(this, _WsProvider_websocket, "f")) {
                tslib_1.__classPrivateFieldGet(this, _WsProvider_websocket, "f").onclose = tslib_1.__classPrivateFieldGet(this, _WsProvider_onSocketClose, "f");
                tslib_1.__classPrivateFieldGet(this, _WsProvider_websocket, "f").onerror = tslib_1.__classPrivateFieldGet(this, _WsProvider_onSocketError, "f");
                tslib_1.__classPrivateFieldGet(this, _WsProvider_websocket, "f").onmessage = tslib_1.__classPrivateFieldGet(this, _WsProvider_onSocketMessage, "f");
                tslib_1.__classPrivateFieldGet(this, _WsProvider_websocket, "f").onopen = tslib_1.__classPrivateFieldGet(this, _WsProvider_onSocketOpen, "f");
            }
            // timeout any handlers that have not had a response
            tslib_1.__classPrivateFieldSet(this, _WsProvider_timeoutId, setInterval(() => tslib_1.__classPrivateFieldGet(this, _WsProvider_timeoutHandlers, "f").call(this), TIMEOUT_INTERVAL), "f");
        }
        catch (error) {
            l.error(error);
            tslib_1.__classPrivateFieldGet(this, _WsProvider_emit, "f").call(this, 'error', error);
            throw error;
        }
    }
    /**
     * @description Connect, never throwing an error, but rather forcing a retry
     */
    async connectWithRetry() {
        if (tslib_1.__classPrivateFieldGet(this, _WsProvider_autoConnectMs, "f") > 0) {
            try {
                await this.connect();
            }
            catch (error) {
                setTimeout(() => {
                    this.connectWithRetry().catch(() => {
                        // does not throw
                    });
                }, tslib_1.__classPrivateFieldGet(this, _WsProvider_autoConnectMs, "f"));
            }
        }
    }
    /**
     * @description Manually disconnect from the connection, clearing auto-connect logic
     */
    // eslint-disable-next-line @typescript-eslint/require-await
    async disconnect() {
        // switch off autoConnect, we are in manual mode now
        tslib_1.__classPrivateFieldSet(this, _WsProvider_autoConnectMs, 0, "f");
        try {
            if (tslib_1.__classPrivateFieldGet(this, _WsProvider_websocket, "f")) {
                // 1000 - Normal closure; the connection successfully completed
                tslib_1.__classPrivateFieldGet(this, _WsProvider_websocket, "f").close(1000);
            }
        }
        catch (error) {
            l.error(error);
            tslib_1.__classPrivateFieldGet(this, _WsProvider_emit, "f").call(this, 'error', error);
            throw error;
        }
    }
    /**
     * @description Returns the connection stats
     */
    get stats() {
        return {
            active: {
                requests: Object.keys(tslib_1.__classPrivateFieldGet(this, _WsProvider_handlers, "f")).length,
                subscriptions: Object.keys(tslib_1.__classPrivateFieldGet(this, _WsProvider_subscriptions, "f")).length
            },
            total: tslib_1.__classPrivateFieldGet(this, _WsProvider_stats, "f").total
        };
    }
    get endpointStats() {
        return tslib_1.__classPrivateFieldGet(this, _WsProvider_endpointStats, "f");
    }
    /**
     * @summary Listens on events after having subscribed using the [[subscribe]] function.
     * @param  {ProviderInterfaceEmitted} type Event
     * @param  {ProviderInterfaceEmitCb}  sub  Callback
     * @return unsubscribe function
     */
    on(type, sub) {
        tslib_1.__classPrivateFieldGet(this, _WsProvider_eventemitter, "f").on(type, sub);
        return () => {
            tslib_1.__classPrivateFieldGet(this, _WsProvider_eventemitter, "f").removeListener(type, sub);
        };
    }
    /**
     * @summary Send JSON data using WebSockets to configured HTTP Endpoint or queue.
     * @param method The RPC methods to execute
     * @param params Encoded parameters as applicable for the method
     * @param subscription Subscription details (internally used)
     */
    send(method, params, isCacheable, subscription) {
        tslib_1.__classPrivateFieldGet(this, _WsProvider_endpointStats, "f").requests++;
        tslib_1.__classPrivateFieldGet(this, _WsProvider_stats, "f").total.requests++;
        const [id, body] = tslib_1.__classPrivateFieldGet(this, _WsProvider_coder, "f").encodeJson(method, params);
        let resultPromise = isCacheable
            ? tslib_1.__classPrivateFieldGet(this, _WsProvider_callCache, "f").get(body)
            : null;
        if (!resultPromise) {
            resultPromise = tslib_1.__classPrivateFieldGet(this, _WsProvider_instances, "m", _WsProvider_send).call(this, id, body, method, params, subscription);
            if (isCacheable) {
                tslib_1.__classPrivateFieldGet(this, _WsProvider_callCache, "f").set(body, resultPromise);
            }
        }
        else {
            tslib_1.__classPrivateFieldGet(this, _WsProvider_endpointStats, "f").cached++;
            tslib_1.__classPrivateFieldGet(this, _WsProvider_stats, "f").total.cached++;
        }
        return resultPromise;
    }
    /**
     * @name subscribe
     * @summary Allows subscribing to a specific event.
     *
     * @example
     * <BR>
     *
     * ```javascript
     * const provider = new WsProvider('ws://127.0.0.1:9944');
     * const rpc = new Rpc(provider);
     *
     * rpc.state.subscribeStorage([[storage.system.account, <Address>]], (_, values) => {
     *   console.log(values)
     * }).then((subscriptionId) => {
     *   console.log('balance changes subscription id: ', subscriptionId)
     * })
     * ```
     */
    subscribe(type, method, params, callback) {
        tslib_1.__classPrivateFieldGet(this, _WsProvider_endpointStats, "f").subscriptions++;
        tslib_1.__classPrivateFieldGet(this, _WsProvider_stats, "f").total.subscriptions++;
        // subscriptions are not cached, LRU applies to .at(<blockHash>) only
        return this.send(method, params, false, { callback, type });
    }
    /**
     * @summary Allows unsubscribing to subscriptions made with [[subscribe]].
     */
    async unsubscribe(type, method, id) {
        const subscription = `${type}::${id}`;
        // FIXME This now could happen with re-subscriptions. The issue is that with a re-sub
        // the assigned id now does not match what the API user originally received. It has
        // a slight complication in solving - since we cannot rely on the send id, but rather
        // need to find the actual subscription id to map it
        if ((0, util_1.isUndefined)(tslib_1.__classPrivateFieldGet(this, _WsProvider_subscriptions, "f")[subscription])) {
            l.debug(() => `Unable to find active subscription=${subscription}`);
            return false;
        }
        delete tslib_1.__classPrivateFieldGet(this, _WsProvider_subscriptions, "f")[subscription];
        try {
            return this.isConnected && !(0, util_1.isNull)(tslib_1.__classPrivateFieldGet(this, _WsProvider_websocket, "f"))
                ? this.send(method, [id])
                : true;
        }
        catch (error) {
            return false;
        }
    }
}
exports.WsProvider = WsProvider;
_WsProvider_callCache = new WeakMap(), _WsProvider_coder = new WeakMap(), _WsProvider_endpoints = new WeakMap(), _WsProvider_headers = new WeakMap(), _WsProvider_eventemitter = new WeakMap(), _WsProvider_handlers = new WeakMap(), _WsProvider_isReadyPromise = new WeakMap(), _WsProvider_stats = new WeakMap(), _WsProvider_waitingForId = new WeakMap(), _WsProvider_autoConnectMs = new WeakMap(), _WsProvider_endpointIndex = new WeakMap(), _WsProvider_endpointStats = new WeakMap(), _WsProvider_isConnected = new WeakMap(), _WsProvider_subscriptions = new WeakMap(), _WsProvider_timeoutId = new WeakMap(), _WsProvider_websocket = new WeakMap(), _WsProvider_timeout = new WeakMap(), _WsProvider_emit = new WeakMap(), _WsProvider_onSocketClose = new WeakMap(), _WsProvider_onSocketError = new WeakMap(), _WsProvider_onSocketMessage = new WeakMap(), _WsProvider_onSocketMessageResult = new WeakMap(), _WsProvider_onSocketMessageSubscribe = new WeakMap(), _WsProvider_onSocketOpen = new WeakMap(), _WsProvider_resubscribe = new WeakMap(), _WsProvider_timeoutHandlers = new WeakMap(), _WsProvider_instances = new WeakSet(), _WsProvider_send = async function _WsProvider_send(id, body, method, params, subscription) {
    return new Promise((resolve, reject) => {
        try {
            if (!this.isConnected || tslib_1.__classPrivateFieldGet(this, _WsProvider_websocket, "f") === null) {
                throw new Error('WebSocket is not connected');
            }
            const callback = (error, result) => {
                error
                    ? reject(error)
                    : resolve(result);
            };
            l.debug(() => ['calling', method, body]);
            tslib_1.__classPrivateFieldGet(this, _WsProvider_handlers, "f")[id] = {
                callback,
                method,
                params,
                start: Date.now(),
                subscription
            };
            tslib_1.__classPrivateFieldGet(this, _WsProvider_endpointStats, "f").bytesSent += body.length;
            tslib_1.__classPrivateFieldGet(this, _WsProvider_stats, "f").total.bytesSent += body.length;
            tslib_1.__classPrivateFieldGet(this, _WsProvider_websocket, "f").send(body);
        }
        catch (error) {
            tslib_1.__classPrivateFieldGet(this, _WsProvider_endpointStats, "f").errors++;
            tslib_1.__classPrivateFieldGet(this, _WsProvider_stats, "f").total.errors++;
            reject(error);
        }
    });
};
