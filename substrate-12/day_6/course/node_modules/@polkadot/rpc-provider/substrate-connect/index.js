var _ScProvider_Sc, _ScProvider_coder, _ScProvider_spec, _ScProvider_sharedSandbox, _ScProvider_subscriptions, _ScProvider_resubscribeMethods, _ScProvider_requests, _ScProvider_wellKnownChains, _ScProvider_eventemitter, _ScProvider_chain, _ScProvider_isChainReady, _ScProvider_resubscribe;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { EventEmitter } from 'eventemitter3';
import { isError, isFunction, isObject, logger, objectSpread } from '@polkadot/util';
import { RpcCoder } from '../coder/index.js';
import { healthChecker } from './Health.js';
const l = logger('api-substrate-connect');
const subscriptionUnsubscriptionMethods = new Map([
    ['author_submitAndWatchExtrinsic', 'author_unwatchExtrinsic'],
    ['chain_subscribeAllHeads', 'chain_unsubscribeAllHeads'],
    ['chain_subscribeFinalizedHeads', 'chain_unsubscribeFinalizedHeads'],
    ['chain_subscribeFinalisedHeads', 'chain_subscribeFinalisedHeads'],
    ['chain_subscribeNewHeads', 'chain_unsubscribeNewHeads'],
    ['chain_subscribeNewHead', 'chain_unsubscribeNewHead'],
    ['chain_subscribeRuntimeVersion', 'chain_unsubscribeRuntimeVersion'],
    ['subscribe_newHead', 'unsubscribe_newHead'],
    ['state_subscribeRuntimeVersion', 'state_unsubscribeRuntimeVersion'],
    ['state_subscribeStorage', 'state_unsubscribeStorage']
]);
const scClients = new WeakMap();
export class ScProvider {
    constructor(Sc, spec, sharedSandbox) {
        _ScProvider_Sc.set(this, void 0);
        _ScProvider_coder.set(this, new RpcCoder());
        _ScProvider_spec.set(this, void 0);
        _ScProvider_sharedSandbox.set(this, void 0);
        _ScProvider_subscriptions.set(this, new Map());
        _ScProvider_resubscribeMethods.set(this, new Map());
        _ScProvider_requests.set(this, new Map());
        _ScProvider_wellKnownChains.set(this, void 0);
        _ScProvider_eventemitter.set(this, new EventEmitter());
        _ScProvider_chain.set(this, null);
        _ScProvider_isChainReady.set(this, false);
        _ScProvider_resubscribe.set(this, () => {
            const promises = [];
            __classPrivateFieldGet(this, _ScProvider_resubscribeMethods, "f").forEach((subDetails) => {
                // only re-create subscriptions which are not in author (only area where
                // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'
                // are not included (and will not be re-broadcast)
                if (subDetails.type.startsWith('author_')) {
                    return;
                }
                try {
                    const promise = new Promise((resolve) => {
                        this.subscribe(subDetails.type, subDetails.method, subDetails.params, subDetails.callback).catch((error) => console.log(error));
                        resolve();
                    });
                    promises.push(promise);
                }
                catch (error) {
                    l.error(error);
                }
            });
            Promise.all(promises).catch((err) => l.log(err));
        });
        if (!isObject(Sc) || !isObject(Sc.WellKnownChain) || !isFunction(Sc.createScClient)) {
            throw new Error('Expected an @substrate/connect interface as first parameter to ScProvider');
        }
        __classPrivateFieldSet(this, _ScProvider_Sc, Sc, "f");
        __classPrivateFieldSet(this, _ScProvider_spec, spec, "f");
        __classPrivateFieldSet(this, _ScProvider_sharedSandbox, sharedSandbox, "f");
        __classPrivateFieldSet(this, _ScProvider_wellKnownChains, new Set(Object.values(Sc.WellKnownChain)), "f");
    }
    get hasSubscriptions() {
        // Indicates that subscriptions are supported
        return true;
    }
    get isClonable() {
        return false;
    }
    get isConnected() {
        return !!__classPrivateFieldGet(this, _ScProvider_chain, "f") && __classPrivateFieldGet(this, _ScProvider_isChainReady, "f");
    }
    clone() {
        throw new Error('clone() is not supported.');
    }
    // Config details can be found in @substrate/connect repo following the link:
    // https://github.com/paritytech/substrate-connect/blob/main/packages/connect/src/connector/index.ts
    async connect(config, checkerFactory = healthChecker) {
        if (this.isConnected) {
            throw new Error('Already connected!');
        }
        // it could happen that after emitting `disconnected` due to the fact taht
        // smoldot is syncing, the consumer tries to reconnect after a certain amount
        // of time... In which case we want to make sure that we don't create a new
        // chain.
        if (__classPrivateFieldGet(this, _ScProvider_chain, "f")) {
            await __classPrivateFieldGet(this, _ScProvider_chain, "f");
            return;
        }
        if (__classPrivateFieldGet(this, _ScProvider_sharedSandbox, "f") && !__classPrivateFieldGet(this, _ScProvider_sharedSandbox, "f").isConnected) {
            await __classPrivateFieldGet(this, _ScProvider_sharedSandbox, "f").connect();
        }
        const client = __classPrivateFieldGet(this, _ScProvider_sharedSandbox, "f")
            ? scClients.get(__classPrivateFieldGet(this, _ScProvider_sharedSandbox, "f"))
            : __classPrivateFieldGet(this, _ScProvider_Sc, "f").createScClient(config);
        if (!client) {
            throw new Error('Unkown ScProvider!');
        }
        scClients.set(this, client);
        const hc = checkerFactory();
        const onResponse = (res) => {
            const hcRes = hc.responsePassThrough(res);
            if (!hcRes) {
                return;
            }
            const response = JSON.parse(hcRes);
            let decodedResponse;
            try {
                decodedResponse = __classPrivateFieldGet(this, _ScProvider_coder, "f").decodeResponse(response);
            }
            catch (e) {
                decodedResponse = e;
            }
            // It's not a subscription message, but rather a standar RPC response
            if (response.params?.subscription === undefined || !response.method) {
                return __classPrivateFieldGet(this, _ScProvider_requests, "f").get(response.id)?.(decodedResponse);
            }
            // We are dealing with a subscription message
            const subscriptionId = `${response.method}::${response.params.subscription}`;
            const callback = __classPrivateFieldGet(this, _ScProvider_subscriptions, "f").get(subscriptionId)?.[0];
            callback?.(decodedResponse);
        };
        const addChain = __classPrivateFieldGet(this, _ScProvider_wellKnownChains, "f").has(__classPrivateFieldGet(this, _ScProvider_spec, "f"))
            ? client.addWellKnownChain
            : client.addChain;
        __classPrivateFieldSet(this, _ScProvider_chain, addChain(__classPrivateFieldGet(this, _ScProvider_spec, "f"), onResponse).then((chain) => {
            hc.setSendJsonRpc(chain.sendJsonRpc);
            __classPrivateFieldSet(this, _ScProvider_isChainReady, false, "f");
            const cleanup = () => {
                // If there are any callbacks left, we have to reject/error them.
                // Otherwise, that would cause a memory leak.
                const disconnectionError = new Error('Disconnected');
                __classPrivateFieldGet(this, _ScProvider_requests, "f").forEach((cb) => cb(disconnectionError));
                __classPrivateFieldGet(this, _ScProvider_subscriptions, "f").forEach(([cb]) => cb(disconnectionError));
                __classPrivateFieldGet(this, _ScProvider_subscriptions, "f").clear();
            };
            const staleSubscriptions = [];
            const killStaleSubscriptions = () => {
                if (staleSubscriptions.length === 0) {
                    return;
                }
                const stale = staleSubscriptions.pop();
                if (!stale) {
                    throw new Error('Unable to get stale subscription');
                }
                const { id, unsubscribeMethod } = stale;
                Promise
                    .race([
                    this.send(unsubscribeMethod, [id]).catch(() => undefined),
                    new Promise((resolve) => setTimeout(resolve, 500))
                ])
                    .then(killStaleSubscriptions)
                    .catch(() => undefined);
            };
            hc.start((health) => {
                const isReady = !health.isSyncing && (health.peers > 0 || !health.shouldHavePeers);
                // if it's the same as before, then nothing has changed and we are done
                if (__classPrivateFieldGet(this, _ScProvider_isChainReady, "f") === isReady) {
                    return;
                }
                __classPrivateFieldSet(this, _ScProvider_isChainReady, isReady, "f");
                if (!isReady) {
                    // If we've reached this point, that means that the chain used to be "ready"
                    // and now we are about to emit `disconnected`.
                    //
                    // This will cause the PolkadotJs API think that the connection is
                    // actually dead. In reality the smoldot chain is not dead, of course.
                    // However, we have to cleanup all the existing callbacks because when
                    // the smoldot chain stops syncing, then we will emit `connected` and
                    // the PolkadotJs API will try to re-create the previous
                    // subscriptions and requests. Although, now is not a good moment
                    // to be sending unsubscription messages to the smoldot chain, we
                    // should wait until is no longer syncing to send the unsubscription
                    // messages from the stale subscriptions of the previous connection.
                    //
                    // That's why -before we perform the cleanup of `this.#subscriptions`-
                    // we keep the necessary information that we will need later on to
                    // kill the stale subscriptions.
                    [...__classPrivateFieldGet(this, _ScProvider_subscriptions, "f").values()].forEach((s) => {
                        staleSubscriptions.push(s[1]);
                    });
                    cleanup();
                    __classPrivateFieldGet(this, _ScProvider_eventemitter, "f").emit('disconnected');
                }
                else {
                    killStaleSubscriptions();
                    __classPrivateFieldGet(this, _ScProvider_eventemitter, "f").emit('connected');
                    if (__classPrivateFieldGet(this, _ScProvider_resubscribeMethods, "f").size) {
                        __classPrivateFieldGet(this, _ScProvider_resubscribe, "f").call(this);
                    }
                }
            });
            return objectSpread({}, chain, {
                remove: () => {
                    hc.stop();
                    chain.remove();
                    cleanup();
                },
                sendJsonRpc: hc.sendJsonRpc.bind(hc)
            });
        }), "f");
        try {
            await __classPrivateFieldGet(this, _ScProvider_chain, "f");
        }
        catch (e) {
            __classPrivateFieldSet(this, _ScProvider_chain, null, "f");
            __classPrivateFieldGet(this, _ScProvider_eventemitter, "f").emit('error', e);
            throw e;
        }
    }
    async disconnect() {
        if (!__classPrivateFieldGet(this, _ScProvider_chain, "f")) {
            return;
        }
        const chain = await __classPrivateFieldGet(this, _ScProvider_chain, "f");
        __classPrivateFieldSet(this, _ScProvider_chain, null, "f");
        __classPrivateFieldSet(this, _ScProvider_isChainReady, false, "f");
        try {
            chain.remove();
        }
        catch (_) { }
        __classPrivateFieldGet(this, _ScProvider_eventemitter, "f").emit('disconnected');
    }
    on(type, sub) {
        // It's possible. Although, quite unlikely, that by the time that polkadot
        // subscribes to the `connected` event, the Provider is already connected.
        // In that case, we must emit to let the consumer know that we are connected.
        if (type === 'connected' && this.isConnected) {
            sub();
        }
        __classPrivateFieldGet(this, _ScProvider_eventemitter, "f").on(type, sub);
        return () => {
            __classPrivateFieldGet(this, _ScProvider_eventemitter, "f").removeListener(type, sub);
        };
    }
    async send(method, params) {
        if (!this.isConnected || !__classPrivateFieldGet(this, _ScProvider_chain, "f")) {
            throw new Error('Provider is not connected');
        }
        const chain = await __classPrivateFieldGet(this, _ScProvider_chain, "f");
        const [id, json] = __classPrivateFieldGet(this, _ScProvider_coder, "f").encodeJson(method, params);
        const result = new Promise((resolve, reject) => {
            __classPrivateFieldGet(this, _ScProvider_requests, "f").set(id, (response) => {
                (isError(response) ? reject : resolve)(response);
            });
            try {
                chain.sendJsonRpc(json);
            }
            catch (e) {
                __classPrivateFieldSet(this, _ScProvider_chain, null, "f");
                try {
                    chain.remove();
                }
                catch (_) { }
                __classPrivateFieldGet(this, _ScProvider_eventemitter, "f").emit('error', e);
            }
        });
        try {
            return await result;
        }
        finally {
            // let's ensure that once the Promise is resolved/rejected, then we remove
            // remove its entry from the internal #requests
            __classPrivateFieldGet(this, _ScProvider_requests, "f").delete(id);
        }
    }
    async subscribe(type, method, params, callback) {
        if (!subscriptionUnsubscriptionMethods.has(method)) {
            throw new Error(`Unsupported subscribe method: ${method}`);
        }
        const id = await this.send(method, params);
        const subscriptionId = `${type}::${id}`;
        const cb = (response) => {
            if (response instanceof Error) {
                callback(response, undefined);
            }
            else {
                callback(null, response);
            }
        };
        const unsubscribeMethod = subscriptionUnsubscriptionMethods.get(method);
        if (!unsubscribeMethod) {
            throw new Error('Invalid unsubscribe method found');
        }
        __classPrivateFieldGet(this, _ScProvider_resubscribeMethods, "f").set(subscriptionId, { callback, method, params, type });
        __classPrivateFieldGet(this, _ScProvider_subscriptions, "f").set(subscriptionId, [cb, { id, unsubscribeMethod }]);
        return id;
    }
    unsubscribe(type, method, id) {
        if (!this.isConnected) {
            throw new Error('Provider is not connected');
        }
        const subscriptionId = `${type}::${id}`;
        if (!__classPrivateFieldGet(this, _ScProvider_subscriptions, "f").has(subscriptionId)) {
            return Promise.reject(new Error(`Unable to find active subscription=${subscriptionId}`));
        }
        __classPrivateFieldGet(this, _ScProvider_resubscribeMethods, "f").delete(subscriptionId);
        __classPrivateFieldGet(this, _ScProvider_subscriptions, "f").delete(subscriptionId);
        return this.send(method, [id]);
    }
}
_ScProvider_Sc = new WeakMap(), _ScProvider_coder = new WeakMap(), _ScProvider_spec = new WeakMap(), _ScProvider_sharedSandbox = new WeakMap(), _ScProvider_subscriptions = new WeakMap(), _ScProvider_resubscribeMethods = new WeakMap(), _ScProvider_requests = new WeakMap(), _ScProvider_wellKnownChains = new WeakMap(), _ScProvider_eventemitter = new WeakMap(), _ScProvider_chain = new WeakMap(), _ScProvider_isChainReady = new WeakMap(), _ScProvider_resubscribe = new WeakMap();
